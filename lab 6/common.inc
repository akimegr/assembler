;В данном файлике хранятся функции, которые удобно использовать для выполнения большинства контрольных работ по МПиМК/АЛОЦА.
;© 2006 by Das :)
;Можете свободно использовать, копировать, изменять и даже справшивать объяснений. Just give credit where credit is due.

comment @
Процедура паузы. Писалась очень долго и много раз переписывалась. Один из окончательных вариантов
Параметры:
	- len - длина паузы (в миллисекундах, 55-65535)
	- callback - смещение функции, которая будет вызываться во время ожидания. Если 0 - не вызывается
Такая функция может использоваться для прерывания паузы по какому-либо условию (нажатию клавиши). Если функция возвращается в AX не 0 - пауза прерывается. Функция не должна долго работать.
Пауза делается с погрешностью ~30 миллисекунд.
@
pause proc C uses ax bx cx dx es, len, callback
	mov ax,len	;AX=len
	mov bx,55	;BX=55
	xor dx,dx	;DX=0
	div bx		;AX=DX|AX/BX=AX/55 - вычисление количества тактов таймера (таймер вызывается примерно 18.2 раза в секунду = 1 раз в 55 миллисекунд)
	mov cx,ax	;CX=AX=количество тактов
	xor ax,ax	;AX=0
	mov es,ax	;ES=AX=0 - формирование сегментного адреса (смещение укажем явно)
_read:
	mov ax,callback	;AX=callback
	test ax,ax	;если AX=0 - не вызываем функцию
	jz _continue
	call ax		;вызываем функцию
	test ax,ax	;если вернули не 0 - выходим
	jz _continue
	ret
_continue:
	mov ax,es:[046Ch]	;AX=ES:[046Ch]=[0000h:046Ch] - по этому адресу хранится некое значение, которое изменяется 1 раз в такт (в 55 миллисекунд)
	cmp bx,ax	;Если BX=AX
	je _read	;Ждём дальше, пока значение не изменится
	mov bx,ax	;BX=AX - иначе запоминаем новое значение
	loop _read	;и уменьшаем CX на 1 - ждать осталось меньше
	ret
pause endp

comment @
Процедура вывода на экран строки. Просто оболочка для прерывания DOS 9.
Параметры:
	- string - смещение выводимой строки в сегменте DS
@
write proc C uses ax dx, string
	mov ah,9	;AH=9 - функция DOS буферизированного вывода
	mov dx,string	;DS:DX - адрес выводимой строки
	int 21h
	ret
write endp

comment @
Процедура считывания строки. Просто оболочка для прерывания DOS 0A.
Параметры:
	- buf - смещение строки в сегменте DS
Строка для данного прерывания должна содержать на входе: первый байт - ёмкость буфера, третий и дальше - сам буфер.
На входе в строке: второй байт - количество считанных символов без 0Dh, третий и дальше - считанные символы (на конце - 0Dh)
@
read proc C uses ax dx, buf
	mov ah,0Ah	;AH=0Ah - функция DOS буферизированного ввода
	mov dx,buf	;DS:DX - адрес буфера
	int 21h
	ret
read endp

comment @
Выход из программы
@
exit proc C
	mov ax,4C00h	;AX=4C00h: AH=4Ch - функция DOS завершения программы, AL=0 - возвращаемый код, соответствует нормальному завершению 
	int 21h
exit endp

comment @
Процедура запуска звукового сигнала.
Параметры:
	- frequency - частота сигнала в Гц
Для формирования звукового сигнала используется таймер и динамик. Если вам очень нужно понять строки без комментариев - П.И. Финогенов, К.Г. Финогенов "Программируем на языке Ассемблера IBM PC", 3 издание, ISBN 5-89657-009-0
@
sound proc C uses ax bx dx, frequency
	in al,61h
	or al,3
	out 61h,al
	mov al,10110110b
	out 43h,al
	;Для формирования необходимого звукового сигнала необходимо частоту в герцах умножить на 1.139
	mov ax,frequency	;AX=frequency
	xor dx,dx	;DX=0
	mov bx,1139	;BX=1139
	mul bx		;DX|AX=AX*BX=AX*1139=frequency*1139
	mov bx,1000	;BX=1000
	div bx		;AX=DX|AX/BX=DX|AX/1000=frequency*1139/1000=frequency*1.139
	out 42h,al
	mov al,ah
	out 42h,al
	in al,61h
	or al,11b
	out 61h,al
	ret
sound endp

comment @
Процедура остановки звукового сигнала. Объяснение - там же.
@
nosound proc C uses ax
	in al,61h
	and al,not 11b
	out 61h,al
	ret
nosound endp

comment @
Процедура перевода беззнакового числа в строку.
Параметры:
	- num - число, которое надо перевести. 0 - 65535 (т.е. слово)
	- string - смещение КОНЦА строки, в которой будет храниться результат. Строка будет оканчиваться $. Результат будет в КОНЦЕ строки. Строка должна быть достаточно большой, чтобы вместить результат 
	- base - основание системы счисления (обычно 2,8,10,16)
На выходе в AX будет храниться смещение первого байта результата.
Процедура несложная. Не разберётесь - не получите зачёт. Рекомендую ПОДУМАТЬ, а потом задавать вопросы.
@
num2str proc C uses bx cx dx di, num, string, base
	mov di,string
	mov al,'$'
	mov [di],al
	dec di
	mov bx,base
	mov ax,num
_n:	xor dx,dx
	div bx
	or dl,'0'
	mov [di],dl
	dec di
	test ax,ax
	jnz _n
	mov ax,di
	inc ax
	ret
num2str endp

comment @
Процедура перевода строки в число.
Параметры:
	- strlen - длина строки с числом (число без знака, 0-65535)
	- string - смещение строки с числом
	- base - основание системы счисления (обычно 2,8,10,16)
На выходе в AX будет храниться полученное число.
Процедура несложная. Не разберётесь - не получите зачёт. Рекомендую ПОДУМАТЬ, а потом задавать вопросы.
@
str2num proc C uses bx cx si, strlen, string, base
	mov bx,1
	push 0
	mov si,string
	add si,strlen
	dec si
	mov cx,strlen
_b:	xor ah,ah
	mov al,[si]
	sub al,'0'
	mul bx
	pop dx
	add dx,ax
	push dx
	mov ax,bx
	mul base
	mov bx,ax
	dec si
	loop _b
	pop ax
	ret
str2num endp